(()=>{class t extends HTMLElement{constructor(){super(),this.pointSize=5,this.lineSize=2,this.points=[],this.connections=[],this.polygonDrawn=!1,this.creationMode=!1,this.validPolygon=!1,this.drawPathInfo={direction:"clockwise",pickedPoint:"",pathPoints:[],start:null,end:null},this.shadow=this.attachShadow({mode:"open"}),this.loadSaved()}connectedCallback(){this.render()}indexToName(t){return"p"+String(t+1)}loadSaved(){let t=localStorage.getItem("polygonEditorData");t&&(t=JSON.parse(t),this.points=t,this.validPolygon=!0,this.polygonDrawn,this.drawPolygon())}clearSaved(){localStorage.removeItem("polygonEditorData")}clearPath(){this.drawPathInfo.pathPoints=[],this.connections=this.connections.map((t=>(t.partOfPath=!1,t))),this.render()}attachEventListeners(){if(this.shadow.querySelector("#createPoints").addEventListener("click",this.switchCreateMode.bind(this)),this.shadow.querySelector("#drawPolygon").addEventListener("click",this.drawPolygon.bind(this)),this.creationMode){try{this.shadow.querySelector("#polygonEditorPreview").removeEventListener("click",this.pickCurrentPoint.bind(this))}catch(t){}this.shadow.querySelector("#polygonEditorPreview").addEventListener("click",this.placePoint.bind(this)),this.shadow.querySelector("#polygonEditorPreview").addEventListener("contextmenu",(t=>{t.preventDefault(),this.points.pop(),this.render()}))}else try{this.shadow.querySelector("#polygonEditorPreview").removeEventListener("click",this.placePoint.bind(this))}catch(t){}this.shadow.querySelectorAll("[data-pick-point]").forEach((t=>{t.addEventListener("click",(t=>{this.drawPathInfo.pickedPoint=t.target.dataset.pickPoint,this.render()}))})),this.drawPathInfo.pickedPoint&&this.shadow.querySelectorAll("[data-point-key]").forEach((t=>{t.addEventListener("click",this.pickCurrentPoint.bind(this))})),this.shadow.querySelector("#pathClear").addEventListener("click",(()=>{this.points=[],this.connections=[],this.polygonDrawn=!1,this.drawPathInfo={direction:"clockwise",pickedPoint:"",pathPoints:[],start:null,end:null},this.clearSaved(),this.render()})),this.drawPathInfo.pathPoints.length&&this.shadow.querySelector("#changeDirection").addEventListener("click",(t=>{this.drawPathInfo.direction="clockwise"==this.drawPathInfo.direction?"counterClockwise":"clockwise",this.clearPath(),this.drawPath(),this.render()}))}switchCreateMode(){this.creationMode=!this.creationMode&&!this.polygonDrawn,console.log("new mode: ",this.creationMode),this.render()}placePoint(t){console.log(t.target),console.log(this);let n=t.target.createSVGPoint();n.x=t.clientX,n.y=t.clientY;let{x:i,y:o}=n.matrixTransform(t.target.getScreenCTM().inverse());this.points.push({x:i,y:o,name:"p"+(this.points.length+1)}),console.log(this.points),this.render()}pickCurrentPoint(t){if(this.drawPathInfo.pickedPoint&&t.target.dataset.pointKey){if(console.log(t.target),this.drawPathInfo[this.drawPathInfo.pickedPoint]=Number(t.target.dataset.pointKey),this.drawPathInfo.pickedPoint="",null!==this.drawPathInfo.start&&null!==this.drawPathInfo.end)if(this.drawPathInfo.start===this.drawPathInfo.end){let t="start"==this.drawPathInfo.pickedPoint?"end":"start";this.drawPathInfo[t]=null}else this.clearPath(),this.drawPath();this.render()}}drawPath(){let t,n;for(console.log(this.drawPathInfo.start,this.drawPathInfo.end),"clockwise"==this.drawPathInfo.direction?(t=this.drawPathInfo.start,n=this.drawPathInfo.end):"counterClockwise"==this.drawPathInfo.direction&&(t=this.drawPathInfo.end,n=this.drawPathInfo.start);t!==n;)this.connections[t].partOfPath=!0,this.drawPathInfo.pathPoints.push(this.points[t]),t++,t==this.connections.length&&(t=0);this.drawPathInfo.pathPoints.push(this.points[n]),"counterClockwise"==this.drawPathInfo.direction&&this.drawPathInfo.pathPoints.reverse(),this.render()}drawPolygon(t){this.points.forEach(((t,n)=>{this.connections.push({partOfPath:!1,x1:t.x,y1:t.y,...n==this.points.length-1?{x2:this.points[0].x,y2:this.points[0].y}:{x2:this.points[n+1].x,y2:this.points[n+1].y}})})),this.polygonDrawn=!0,this.switchCreateMode(),localStorage.setItem("polygonEditorData",JSON.stringify(this.points)),this.render()}render(){let t=this.points.length>=3&&this.points.length<=15;const n=t?"#34eb61":"#eb4034",i=`<button id="createPoints" ${this.polygonDrawn?"disabled":""}>${this.polygonDrawn?"You can't add points":this.creationMode?"Stop creating points":"Create points"}</button>`,o=`<span style="color: ${n};" class="pointsStatus">Created ${this.points.length} points</span>`,e=`<button id="drawPolygon" ${this.polygonDrawn||!t?"disabled":""}>${this.polygonDrawn?"✅ Drawn":t?"Draw Polygon":"❌ Your polygon should have 3-15 points"}</button>`,s=this.connections.map(((t,n)=>`<line x1="${t.x1}" y1="${t.y1}" x2="${t.x2}" y2="${t.y2}" stroke="${t.partOfPath?"blue":"black"}" stroke-width="${t.partOfPath?2*this.lineSize:this.lineSize}px"/>`)).join("\n"),a=this.points.map(((t,n)=>`\n            <circle data-point-key="${n}" fill="#f9efd1" stroke="black" cx="${t.x}" cy="${t.y}" r="${this.pointSize}"/>\n            <text fill="#d8d8d8" x="${t.x}" y="${Math.max(0,t.y-2.5*this.pointSize)}">${t.name}</text>\n            `)).join("\n"),r=(t,n)=>`<div class="pointPickWrap">\n                            <button ${(this.drawPathInfo.pickedPoint==n||!this.polygonDrawn)&&"disabled"} data-pick-point="${n}">${this.drawPathInfo.pickedPoint==n?"Choose "+t+" point":t+" point"}</button>\n                            <p>${null===this.drawPathInfo[n]?"N/A":this.points[this.drawPathInfo[n]].name}</p>\n            </div>`;this.shadow.innerHTML=`\n            <style>\n                /*Стили брались на глаз из примера, могут незначительно отличаться от того что было в скриншоте*/\n                .polygonEditorWrap {/*Я не знаком с тем как у вас принято именовать классы, сам обычно именую camelCase т.к. часто загружаю их как модули в React-приложениях*/\n                    min-height: 300px;\n                    background-color: #4c4c4c; \n                    display: flex;\n                    justify-content: space-between;\n                    align-items: start;\n                    gap: 20px;\n                    padding: 10px 20px;\n                    color: #fff;\n                }\n                #polygonEditorPreview{\n                    flex-basis: 60%;\n                    \n                    background-color: #989898;\n                    border: 1px solid #000;\n                }\n                .polygonEditorOptions{ \n                    width: 100%;\n                    display: flex;\n                    flex-direction: column;\n                    align-items: stretch;\n                    gap: 20px;\n                    flex-basis: 30%;\n\n                }\n                .polygonEditorOptionsGroup{\n                    display: flex;\n                    flex-direction: column;\n                    align-items: center;\n                    gap: 5px;\n                }\n                .polygonEditorOptionsGroup button{\n                    background-color: #8f8f8f;\n                    color: #FFF;\n                    border: 1px solid #000;\n                    border-radius: 3px;\n                    padding: 3px 0;\n                    width: 100%;\n                    transition: 0.3s all ease;\n                    /*Посчитал что можно использовать nesting, ориентировался на https://caniuse.com/css-nesting */\n                    &:hover{\n                        filter: brightness(110%);\n                    }\n                    &:active{\n                        transform: scale(0.95); /*я вкурсе про отдельное свойство scale, только не помню, вызывает ли оно GPU, поэтому выбрал традиционный метод*/\n                        filter: brightness(95%);\n                    }\n                    &:disabled{\n                        filter: brightness(50%);\n                    }\n                }\n                .polygonEditorOptionsGroup>h3{\n                    color: #FFF;\n                }\n                .pointsStatus{\n                    text-align: right;\n                    align-self: end;\n                    font-size: 0.5em;\n                }\n                .pointPickWrap{\n                    display: flex;\n                    justify-content: space-around;\n                    align-items: center;\n                    width: 100%;\n                }\n                .pointPickWrap>button{\n                    width: 60%;\n                    text-transform: capitalize;\n                }\n                .polygonEditorOptionsGroup{\n                    font-weight: bold;\n                    font-size: 12px;\n                }\n            </style>\n            <div class="polygonEditorWrap">\n                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 300" id="polygonEditorPreview">\n                    ${s}\n                    ${a}\n                </svg>\n                <div class="polygonEditorOptions">\n                    <div class="polygonEditorOptionsGroup">\n                        <h3>Create Polygons</h3>\n                        ${i}\n                        ${o}\n                        ${e}\n                    </div>\n                    <div class="polygonEditorOptionsGroup">\n                        <h3>Create Path</h3>\n                        ${r("first","start")}\n                        ${r("second","end")}\n                        <button ${!this.polygonDrawn&&"disabled"} id="changeDirection">${"clockwise"==this.drawPathInfo.direction?"Clockwise":"Counterclockwise"} order</button>\n                        <button id="pathClear">Clear</button>\n                        <div id="pathInfo">${this.drawPathInfo.pathPoints.length?"Path: "+this.drawPathInfo.pathPoints.map((t=>t.name)).join(" - "):"Select First and second point to draw a path"}</div>\n                    </div>\n                </div>\n            </div>\n        `,this.attachEventListeners()}}customElements.define("polygon-editor",t)})();